```assembly
section .text
global _start

_start:
        mov al, 65             ; start from ASCII 'A'
        mov ecx, 26            ; 26 letters 

print_chars:
        mov [res], al          ; store current letter into memory

        push ecx               ; save ecx (keep counter value from being overwritten)
        push eax               ; save eax (because overwritten later in system_write)

        mov ecx, res
        call output            ; print letter

        call linefeed          ; print newline

        pop eax                ; restore eax (character)
        pop ecx                ; restore ecx (loop counter)

        inc al                 ; increment to next letter
        loop print_chars       ; loop again

        call exit

linefeed:
        push eax               ; save eax 
        push ecx               ; save ecx

        mov byte [res], 10      ; newline character
        mov ecx, res
        call output

        pop ecx                ; restore ecx
        pop eax                ; restore eax
        ret

output:
        mov eax, 4              ; sys_write
        mov ebx, 1
        mov edx, 1
        int 0x80
        ret

exit:
        mov eax, 1              ; sys_exit
        int 0x80

section .bss
        res resb 1
```

2. The challenges of this week's programming assignment was optimizing the code by using loops and trying to understand where to incorporate loops that would help create a more concise, clean code. I started with the basic code of printing each letter and tried to understand where loops/procedures would be useful. This would occur for the outputs as in printing each letter as well as printing the newlines. Then looping through A-Z by incrementing each loop interval. I used pops/pushes in order to save registers that would be affected in the program, such as when the registers were used for sys_write (outputting), to ensure that there were no overwrites on registers that would cause conflict and errors. 
